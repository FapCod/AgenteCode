# ü§ñ Code Review - PR #3361

üìä **Puntaje General**: 53/100 ‚≠ê‚≠ê
Veredicto: **üö´ REQUEST CHANGES**

## üìà Desglose de Puntaje
| Categor√≠a | Puntaje | Peso | Contribuci√≥n |
|-----------|---------|------|--------------|
| Funcionalidad | 2/5 | 20% | 8.0 |
| Robustez | 2/5 | 20% | 8.0 |
| Mantenibilidad | 3/5 | 20% | 12.0 |
| Testabilidad | 5/5 | 15% | 15.0 |
| Escalabilidad | 2/5 | 10% | 4.0 |
| Arquitectura | 2/5 | 15% | 6.0 |
| **TOTAL** | | | **53/100** |

> **Classification**: L / Alto Risk
> **Reviewer**: AI Auditor (FPININ)
> **Stack Detectado**: Kotlin (Android/Compose), Groovy (Gradle)
> **Desarrollador**: extemendoza_belcorp
> **Fecha**: 2026-02-25
> **¬øListo para fusionar?**: NO

---

## üî¥ Problemas Cr√≠ticos (P0 - Blocking)
> *Issues de seguridad, crashes, o violaciones de reglas estrictas. Deben corregirse obligatoriamente.*

1. **Riesgo de Crash ANR por Petici√≥n de Red S√≠ncrona (runBlocking)**
   - **Archivo**: `unete/src/main/java/biz/belcorp/unete/datalayer/tokenstore/RegisterTokenStoreImpl.kt`, l√≠nea 21.
   - **Problema**: El m√©todo sincr√≥nico `getSecretKey()` envuelve una corrutina y bloquea el hilo subyacente mediante `runBlocking(Dispatchers.IO) { secretsProvider.getUneteRegisterToken() }`. Internamente, el `SecretsProvider` despacha esta solicitud a `cloudStore.getSecrets()` que realiza un `POST` HTTP de red (GraphQL). Si m√©todos invocadores directos o indirectos como `postStep1Token()` operan en el Main Thread de una View, la intefaz congelar√° de forma garantizada su ciclo visual por los MS que le tome conectar a GraphQL, tirando una excepci√≥n de *Application Not Responding* de alta severidad.
   - **Impacto**: Impacto paralizador en el rendimiento UI, quiebra los cimientos de arquitecturas reactivas.
   - **Soluci√≥n Recomendada**: Eliminar por completo el anti-patr√≥n `runBlocking`. Convertir `generateToken` y `postStep1Token` en m√©todos suspendidos (`suspend fun`) para que puedan llamar org√°nicamente y aguardar context-switch a `getUneteRegisterToken()`.

2. **Violaci√≥n de Cero-Comentarios (Regla de Formato)**
   - **Archivos**: `core/src/main/kotlin/biz/belcorp/salesforce/core/data/network/BelcorpApi.kt` (l√≠neas 14-15) y `core/src/main/kotlin/biz/belcorp/salesforce/core/data/repository/secrets/data/SecretsDataStore.kt` (l√≠neas 1-2).
   - **Problema**: Presencia de m√∫ltiples anotaciones `// TODO`, incluyendo referencias que implican eliminar componentes obsoletos (`// TODO: ELIMINAR ESTE ARCHIVO - Ya no se usa`). Esto rompe tajantemente la Regla P0 de estricta limpieza del c√≥digo en main source.
   - **Soluci√≥n Recomendada**: Eliminar directamente del √°rbol de commits el archivo `SecretsDataStore.kt` en vez del comentario instructivo y apartar los comentarios // TODO implementativos de `BelcorpApi.kt`.

---

## üü° Problemas Importantes (P1 - High Priority)
> *Problemas de performance, bugs probables o deuda t√©cnica alta.*

1. **Sobrecarga de Red Incesante / Falta de Cach√© de Memoria (Performance Leak)**
   - **Archivo**: `core/src/main/kotlin/biz/belcorp/salesforce/core/domain/usecases/secrets/GetSecretsUseCase.kt` & `SecretsDataRepository.kt` aleda√±os.
   - **Problema**: La implementaci√≥n ha optado, conforme al comentario, no cachear Secretos globalmente "por motivos de seguridad", implicando persistencia de disco; pero est√° descartando el vital "Cach√© de Memoria RAM" por cada sesi√≥n. Como corolario, cualquier resoluci√≥n desde `secretsProvider.getYoutubeApiKey()`, `getGoogleApiKey()`, u `oauthPassword` desencadena siempre y obligatoriamente una nueva petici√≥n encriptada GraphQL (`post()`). 
   - **Impacto**: Multiplicaci√≥n astron√≥mica del uso de la red cada vez que se navega una Vista Web, mapa, o capa UI acaeciendo demoras en render de milisegundos a segundos para volver a solicitar la misma llave API. 
   - **Soluci√≥n Delineada**: Proveer un variable local en instancia Singleton o memoria Rx en el Capa de Datos (e.g. `var sessionCachedSecret: SecretsData? = null`) que una vez cargado en fr√≠o act√∫e como buffer in-memory mientras dure encendida la app y esquive el salto a Cloud. 

---

## üü¢ Recomendaciones (P2/P3 - Medium/Low)
> *Mejoras de mantenibilidad y buenas pr√°cticas.*

**P2 - Medium Priority:**
- üí° [Arquitectura] M√∫ltiples importaciones Gradle no utilizadas al invocar Kotlin DSL (`import com.google.gson.Gson`, `import com.google.gson.JsonParser`) en `awsSecrets.gradle.kts` mientras que la l√≥gica principal de parseo en ese DSL ya no los implementa o hace uso de JsonSlurper.
- **Soluci√≥n sugerida**: Limpiar los imports del Kotlin DSL script de dependencias Gson si el target de la funci√≥n es nativo o similar.

---

## ‚úÖ Aspectos Positivos
- ‚úÖ Abstracci√≥n madura y altamente escalable en los Build scripts (`awsSecrets.gradle` y `awsSecrets.gradle.kts`) interactuando con IAM y AWS Secrets Manager para limpiar cadenas de texto API hardcodeadas hist√≥ricas, aislando configuraciones y tokens seg√∫n variante (debug, release, stage).
- ‚úÖ Adecuada integraci√≥n Criptogr√°fica AES-256-GCM para el parseo seguro in-code del payload del servidor (AngularSecret & AndroidSecret) sin fugas de texto plano en memoria.  

---

## üìã Plan de Acci√≥n
**Antes de mergear (Requerido):**
- [ ] üî¥ Refactorizar el acceso `getSecretKey()` en `RegisterTokenStoreImpl` transmutando las cadenas colindantes a Coroutines Suspendidas (`suspend`) y anulando `runBlocking`. (30 min)
- [ ] üî¥ Eliminar comentarios TODOs de la API y remover el archivo residual `SecretsDataStore.kt` (5 mins).
- [ ] üü° Aplicar un flag/field Cach√© vol√°til en `SecretsDataRepository.kt` con fin de ahorrar repeticiones al API por secretos inalterables en la duraci√≥n de la sesi√≥n. (20 mins).

---

## üéì Aprendizajes Clave
- ‚ùå **Evitar**: El uso de puentes tipo `runBlocking` como parches para re-sincronizar invocaciones as√≠ncronas en repositorios intermedios cuando la procedencia de datos engloba IO costoso (APIs, BDs); Android lo penaliza violentamente.
- ‚úÖ **Preferir**: Propagar funciones `suspend` hasta la barrera del Presenter/ViewModel o el `lifecycleScope` del Fragment/Activity.

---

## üìù Sugerencia de Pr√≥ximo Commit
 `[SDP-3361] - FIX: Remove explicit RunBlocking for secret key generation and add session volatile cache to prevent multiple network API calls overhead`

---

## üìã Resumen del PR
**¬øQu√© hace este PR?**
Extrae con √©xito cientos de claves incrustadas y las unifica por intermedio de un patr√≥n de Cloud Secrets proveyendo scripts `.gradle` en la base del proyecto junto con un proveedor asincr√≥nico `SecretsProvider` que ataca un backend GraphQL para el cifrado AES de claves corporativas.

**Archivos principales modificados:**
- [NEW] `awsSecrets.gradle` y `awsSecrets.gradle.kts`
- [MODIFY] `core/src/main/kotlin/biz/belcorp/salesforce/core/data/repository/secrets/...` (varios contratos y Decryptors).
- [MODIFY] `unete/src/main/java/biz/belcorp/unete/datalayer/tokenstore/RegisterTokenStoreImpl.kt`

**¬øQu√© Podria impactar?**
Un flujo central de postulaci√≥n o "Unete" puede bloquearse si las llamadas UI son en el Main Thread debido al runBlocking introducente por el nuevo Token Store. 

**Impacto:**
- FUNCIONALIDAD / ARQUITECTURA / RENDIMIENTO

> _Ref: Consultar Ap√©ndice D para referencias oficiales espec√≠ficas de cada lenguaje_
